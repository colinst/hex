---
title: éº»å°†èƒ¡ç‰Œç®—æ³•

tags: 
    - algorithm 
    - game  
    - kotlin  
    - ç®—æ³•  
    - éº»å°†  
    
categories: 
    - algorithm   
    - game  
    
date: 2017-10-010 13:00:00
---

é•¿ä¹…ä»¥æ¥éº»å°†èƒ¡ç‰Œç®—æ³•æ˜¯ä½œä¸ºç»å…¸ç®—æ³•å‡ºç°åœ¨å„ç§åº”ç”¨ä¸­å’Œè¯•é¢˜ä¸­ã€‚  
é•¿ä¹…ä»¥æ¥ä¸»è¦æ¶‰åŠä¸¤ç§ç®—èƒ¡æ–¹æ³•ï¼Œå…¶ä¸€ä¸ºæŸ¥è¡¨æ³•ï¼Œæ‰€æœ‰çš„èƒ¡ç‰Œç‰Œå‹åºåˆ—ï¼Œ
å°†å…¶å­˜å‚¨åœ¨æ•°æ®åº“æˆ–å…¶ä»–åºåˆ—åŒ–æ–‡ä»¶ä¸­ï¼Œä½¿ç”¨æ—¶ç›´æ¥ä»å†…å­˜ä¸­è¯»å–ç›¸åº”çš„å†…å®¹è¿›è¡ŒæŸ¥è¯¢ã€‚  
å¦å¤–ä¸€ç§ç®—æ³•åˆ™ä¸ºæ‹†åˆ†æ³•ï¼Œè®¡ç®—å‡ºå½“å‰ç‰Œå‹ä¸­çš„æ‰€æœ‰åˆ»å­ï¼Œé¢å’Œå°†ï¼Œè§‚å¯Ÿå…¶æ˜¯å¦æ»¡è¶³3n+2çš„æƒ…å†µï¼Œ
æœ¬æ–‡ç€é‡è¯´æ˜æ‹†åˆ†æ³•çš„ç®—æ³•å®ç°ã€‚  
<!-- more -->

## æ€è·¯-
### æ­¥éª¤
1ã€å°†ç‰ŒæŒ‰è¿ç»­æ€§è¿›è¡Œæ‹†åˆ†ï¼Œæ‹†å‡ºçš„ç»„åˆä¸º3*n æˆ– 3*n + 2ï¼Œå¦‚æœæœ‰ä¾‹å¤–ï¼Œåˆ™ä¸èƒ½èƒ¡ã€‚
2ã€æ£€æŸ¥æ•°é‡ä¸º3*nçš„è¿ç»­æ®µæ˜¯å¦æ»¡è¶³èƒ¡ç‰Œæ¡ä»¶ï¼Œå¦‚æœéƒ½èƒ½æ»¡è¶³ï¼Œå†ç”¨æ–¹æ³•3æ£€æŸ¥3*n+2ã€‚  
3ã€åœ¨è¿ç»­çš„ç‰Œä¸­ï¼Œç‰Œå¼ æ•°ä¸º3*n + 2çš„å¼ æ•°æ‹†å‡ºå¯èƒ½çš„å°†ç‰Œã€‚  
4ã€æ‰£é™¤å°†ç‰Œåï¼Œåˆ†åˆ«æ£€æŸ¥å„è¿ç»­çš„æ®µæ˜¯å¦æ»¡è¶³èƒ¡ç‰Œã€‚

### æ£€æŸ¥æ®µ
    
   ä¾‹ï¼šè¿ç»­æ®µä¸º ğŸ€ğŸ€ğŸ€ğŸ€ğŸ€ŸğŸ€ŸğŸ€ ğŸ€ ğŸ€¡  
       æ•°å­—è¡¨ç¤ºä¸º 31221  

   aã€å–3ä½æ•°ä¸ºkeyï¼Œä»ä¸‹è¡¨æŸ¥è¯¢ï¼Œå¦‚æœæœ‰ç»“æœåˆ™æ‰£é™¤è¿™ä¸ªæ•°å­—ã€‚  
      312å–åˆ°ç»“æœ300ï¼Œåˆ™ä½™ä¸‹æ•°å­—ä¸º1221  
   bã€å¦‚æœaæ­¥éª¤æ²¡æœ‰ç»“æœï¼Œåˆ™å–2ä½æ•°ä¸ºkey  
   cã€å¦‚æœbæ­¥éª¤æ²¡æœ‰ç»“æœï¼Œåˆ™å–1ä½æ•°ä¸ºkey  
   å¦‚æœcå¤±è´¥ï¼Œåˆ™ä¸èƒ½èƒ¡  

### 31221æ‹†åˆ†å…¨æ­¥éª¤ï¼š  
   312 = 300 ä½™ 1221  
   122 = 111 ä½™ 111  
   111 = 111 å…¨éƒ¨æ‹†åˆ†å®Œæ¯•ï¼Œèƒ½èƒ¡  

### æ‹†åˆ†è¡¨ï¼š   
[3] = 3, [4] = 3,  
[31] = 30, [32] = 30, 33 = 33, 34 = 33, 44 = 33,  
[111] = 111, [112] = 111, [113] = 111, [114] = 114,  
[122] = 111, [123] = 111, [124] = 111,  
[133] = 111, [134] = 111,  
[141] = 141, [142] = 141, [143] = 141, [144] = 144,  
[222] = 222, [223] = 222, [224] = 222,  
[233] = 222, [234] = 222,  
[244] = 222,  
[311] = 300, [312] = 300, [313] = 300, [314] = 300,  
[322] = 300, [323] = 300, [324] = 300,  
[331] = 330, [332] = 330, [333] = 333, [334] = 333,  
[341] = 330, [342] = 330, [343] = 330, [344] = 333,  
[411] = 411, [412] = 411, [413] = 411, [414] = 414,  
[422] = 411, [423] = 411, [424] = 411,  
[433] = 411, [434] = 411,  
[441] = 441, [442] = 441, [443] = 441, [444] = 444  
 

### è¡¨æ ¼ç”Ÿæˆæ€è·¯ï¼š

1ã€ä»è¾¹ä¸Šå–ç‰Œçš„æ•°é‡  
2ã€å¦‚æœæ˜¯1ï¼Œåˆ™å–111  
3ã€å¦‚æœæ˜¯2ï¼Œåˆ™å–222  
4ã€å¦‚æœæ˜¯3ï¼Œåˆ™å–3  
5ã€å¦‚æœæ˜¯4ï¼Œåˆ™å–411  

## å®ç°

æœ¬éƒ¨åˆ†å®ç°ä»£ç ä¸ºkotlin
ç‰Œå‹çš„è®¾å®šï¼Œä»¥16è¿›åˆ¶æ•°ä»£è¡¨
```
    val cardList = intArrayOf(
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,       //ä¸‡
                0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,       //ç´¢
                0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,       //ç­’
                0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,                   //é£
                0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48 //æ˜¥å¤ç§‹å†¬æ¢…å…°èŠç«¹
        )
```
éº»å°†ç‰Œ
```
    ğŸ€‡ğŸ€ˆğŸ€‰ğŸ€ŠğŸ€‹ğŸ€ŒğŸ€ğŸ€ğŸ€
    ğŸ€ğŸ€‘ğŸ€’ğŸ€“ğŸ€”ğŸ€•ğŸ€–ğŸ€—ğŸ€˜
    ğŸ€™ğŸ€šğŸ€›ğŸ€œğŸ€ğŸ€ğŸ€ŸğŸ€ ğŸ€¡
    ğŸ€€ğŸ€ğŸ€‚ğŸ€ƒğŸ€„ğŸ€…ğŸ€†
    ğŸ€¢ğŸ€£ğŸ€¤ğŸ€¥ğŸ€¦ğŸ€§ğŸ€¨ğŸ€©
```
æµ‹èƒ¡ç‰Œå‹
```
    ğŸ€‡ğŸ€ˆğŸ€‰ ğŸ€‰ğŸ€ŠğŸ€‹ ğŸ€†ğŸ€†ğŸ€† ğŸ€ğŸ€ ğŸ€ğŸ€ğŸ€ğŸ€ŸğŸ€ ğŸ€¡
```
### å‰å¤‡å‡½æ•°
å–å¾—ç‰¹å¾å€¼é•¿åº¦
```
    fun Len(wei:Int)=wei.toString().length
```

10ä¸ºåº•çš„å¹‚å‡½æ•°
```
    fun miIC(di: Int, mi:Int):Int{
            if (di==0)  return 1
            if (mi<0)   return 0
            if (mi==0)  return di
            var r=di
            for (i in 1..mi)
                r*=10
            return r
    }
```

æ­¥è¿›æ˜ å°„è¡¨
```
    fun carry(key: Int): Int {
            when (key) {
                3 -> return 3
                4 -> return 3
    
                31 -> return 30
                32 -> return 30
                33 -> return 33
                44 -> return 33
    
                111 -> return 111
                112 -> return 111
                113 -> return 111
                114 -> return 114
    
                122 -> return 111
                123 -> return 111
                124 -> return 111
    
                133 -> return 111
                134 -> return 111
    
                141 -> return 141
                142 -> return 141
                143 -> return 141
                144 -> return 144
    
                222 -> return 222
                223 -> return 222
                224 -> return 222
    
                233 -> return 222
                234 -> return 222
                244 -> return 222
    
                311 -> return 300
                312 -> return 300
                313 -> return 300
                314 -> return 300
    
                322 -> return 300
                323 -> return 300
                324 -> return 300
    
                331 -> return 330
                332 -> return 330
                333 -> return 333
                334 -> return 333
    
                341 -> return 330
                342 -> return 330
                343 -> return 330
                344 -> return 333
    
                411 -> return 411
                412 -> return 411
                413 -> return 411
                414 -> return 414
    
                422 -> return 411
                423 -> return 411
                424 -> return 411
    
                433 -> return 411
                434 -> return 411
    
                441 -> return 441
                442 -> return 441
                443 -> return 441
                444 -> return 444
            }
            return 0
    }
```

### æ®µè¾…åŠ©å‡½æ•°
è·å–ä¸åŒèŠ±è‰²æ®µçš„æ–­ç‚¹æŒ‡é’ˆ
```
    fun getBreaks(cardArr: IntArray, len: Int):List<Int>{

        val breaks= MutableList<Int>(1,{0})
        for (i in 1 until len)
            if (cardArr[i] - cardArr[i - 1] > 1)
                breaks.add(i)
        breaks.add(len)

        return breaks
    }
```

è·å¾—ä¸€æ®µåŒèŠ±è‰²ç‰Œå‹çš„keyå€¼ï¼Œè¿™é‡Œå®šä¹‰keyå€¼ä¸ºwei
```
    fun getWei(breakS: Int, breakE: Int, cardArr: IntArray): Int {
            //breakS is index of break start,E is end
            var wei = 1
            for (i in (breakE-2) downTo breakS) {
                if (cardArr[i] != cardArr[i + 1])
                    wei += miIC(1, Len(wei))
                else if (cardArr[i] == cardArr[i + 1])
                    wei += miIC(1, Len(wei) - 1)
            }
            return wei
    }
```

ç”±ä»¥ä¸Šä¿©å‡½æ•°å¾—åˆ°ä¸€ç»„ç‰Œä¸­æ‰€æœ‰çš„wei
```
    fun getWeis(cardArr: IntArray, len: Int):List<Int>{
    
            val weis= MutableList<Int>(0,{0})
            val breaks = getBreaks(cardArr,len)
            for ( i in 0..(breaks.size-2)){
                val wei = getWei(breaks[i],breaks[i+1],cardArr)
                weis.add(wei)
            }
            return  weis
    }
```

### å»å°†
æ‹¿åˆ°æ‰€æœ‰å¯èƒ½çš„å°†ç‰Œ
```
    fun getJia(cardArr: IntArray, len: Int): IntArray {
            //all jiangs in it's first index,same size as cardArr
            var flag = true
            val jiangs = IntArray(len)
            for (i in 1 until len) {
                if (cardArr[i] == cardArr[i - 1]) {
                    if (flag) jiangs[i - 1] = cardArr[i]
                    flag = false
                } else flag = true
            }
            return jiangs
    }
```

å»æ‰æ¯ä¸ªå°†åå‰©ä½™ç‰Œç»„çš„é›†åˆ
```
    fun quJiangArrs(cardArr: IntArray, jiangs: IntArray, len: Int): List<IntArray> {
            //all (cardArr[]-jiang) in List
            val quJiangs = MutableList(0,{ IntArray(len,{0}) })
            for (i in 0 until len)
                if (jiangs[i] != 0) {
                    val qujiang=cardArr.clone()
                    qujiang[i]=0
                    qujiang[i+1]=0
                    SortL(qujiang,len)
                    quJiangs.add(qujiang)
                }
            return quJiangs
    }
```

### æ‹†åˆ†æ£€æµ‹
å–weiçš„å‰3ä½æ•°ä¸ºï¼Œå¦‚æœæ˜ å°„é›†ä¸­æœ‰åˆ™æ‰£é™¤è¿™ä¸ªæ•°å­—ã€‚
```
    fun carryChange(weiA: Int): Int {
    
            val lenW = Len(weiA)                           //length_wei
            for (lenk in 3 downTo 1){                      //length_key
                if (lenW-lenk<0)    continue               //carry keystart with 3key,if con't carry,change to 2key,1key. else return itself
                var weiH = (weiA / miIC(1,lenW-lenk))      //weiHead
                if (carry(weiH) != 0)
                    return weiA- miIC(carry(weiH),(lenW-lenk))
            }
            return weiA
    }
```

å•ä¸ªweiçš„æ£€æŸ¥
```
    fun weiThrough(wei: Int): Boolean {
            //circle carryChange until result==0,else return fase
            var cache = wei
            for (i in 1..9) {
                cache = carryChange(cache)
                if (cache == 0) return true
            }
            return false
    }
```

æ‰€æœ‰weiçš„æ£€æŸ¥
```
    fun weisThrough(weis:List<Int>): Boolean {
            for (wei in weis)
                if (!weiThrough(wei))
                    return false
            return true
    }
```


### èƒ¡åˆæ³•æ€»æˆ
```
    fun LegalHu(card: Int,cardArr: IntArray):Boolean{
    
            val arr=cardArr.clone()
            val il= IndexLive(arr)
            val index=il+1
            val len=index+1
    
            if (il==0 && card==arr[0])  return true
    
            arr[index]=card
            Sort(arr,index)
    
            val jiangs= getJia(arr,len)
            val qujiangArrs= quJiangArrs(arr,jiangs,len)
            val ll=il   //ll=len-2=il
    
            for (qujiang in qujiangArrs){
                val weis = getWeis(qujiang,ll)
                val hu= weisThrough(weis)
                if (hu) return true
            }
            return false
    }
```

## æœ€å
è‡³æ­¤ç®—æ³•å®Œæˆï¼Œé™¤å»carryæ˜ å°„æ–¹æ³•æ€»æ–¹æ³•ä¸åˆ°200è¡Œ
ç»æµ‹è¯•ï¼Œå¯¹äº16å¼ çš„å°æ¹¾éº»å°†è€Œè¨€ï¼Œé€Ÿåº¦è¾¾åˆ°æ¯ç§’30Wæ¬¡