---
title: 字符串编码 StringCode

tags: 
    - base 
    - String  
    - Encode  

categories: 
    - Base   
    - code  
    
date: 2018-01-001 13:00:00
---

一般而言，遇到编码问题我们一两行代码就能解决，有时候需要试错。
编码问题是个常见问题，不同语言的编码实现都不同，这里细说一点来备忘。
<!-- more -->

## Base
### 字符 char
```
 a D f
```
以上三种类似，代表基本文字字符

### 字符串 String
```
nice to meet you
```
多个字符组成集合

### 键值表 map
    
    y = x * 2
每个x都对应唯一y值，x与y组成的集合为键值表(HashTable)，如：
    
    1 -> 2
    2 -> 4
    3 -> 6
这里的每一个x(1, 2, 3)都有对应的y(2, 4, 6)
    
### 编码&解码 cod & decode 
编码:将字符串按照一定模式（键值表）转换成二进制再显示存储。
如果把字符串”123”存储起来的话，先要转换成”246”。
计算机实际存储的值是：    

    0010 0100 0110
       2    4    6
故，字符串解码(decode)就是把二进制数据按照一定的模式转换成字符串显示。


## 计算机数据存储
无论是文字图片还是其他数据，计算机都是以”0”或”1”存储的。
如果计算机要存储字符串”GEB”，它会先转换成二进制再存储。
我们使用EngineGo表，他用3位的二进制数字表示8种不同的字符。  
EngineGo表：

| 二进制 | 字符 | 二进制 | 字符 |
| ------ | ---- | ------ | ---- |
| 000    | A    | 100    | E    |
| 001    | B    | 101    | F    |
| 010    | C    | 110    | G    |
| 011    | D    | 111    | H    |
我们在文件编辑器中添加”GEB”字符串保存时，计算机根据EngineGo表存储数据

    110 100 001
      G   E   B 
读取时，计算机会主动猜测应该使用哪个表来还原，
假如它猜对了，使用EngineGo表还原，便会成功得到“GEB”。
猜错了，就乱码了。

##ASCII编码
ASCII编码由西方国家设计，理所当然的用英文作常用字符集，包括大小写字母，数字加上一些标点符号和运算符号大概120个。
3位二进制数字只能表示8个不同的字符，于是我们扩充位数，7位可以表示128个字符，加多1位用作错误检查。
最终使用8位来存储字符，称为一个字节。

| 编号    | 字符 | 编号      | 字符 |
| --------- | ---- | ----------- | ---- |
| （省略）… | …  | 64          | @    |
| 48        | 0    | 65          | A    |
| 49        | 1    | 66(1000010) | B    |
| 50        | 2    | 67          | C    |
| 51        | 3    | 68          | D    |
| 52        | 4    | 69(1000101) | E    |
| 53        | 5    | 70          | F    |
| 54        | 6    | 71(01100111)| G    |
| 55        | 7    | 72          | H    |
| 56        | 8    | 73          | I    |
| 57        | 9    | 74          | J    |
| 58        | :    | 75          | K    |
| 59        | ;    | 76          | L    |
| 60        | <    | 77          | M    |
| 61        | =    | 78          | N    |
| 62        | >    | 79          | O    |
| 63        | ?    | （省略）… | …  |
此时“GEB”被存储为：

    01100111 1000101 1000010
          B       E       B


## GBK编码
但ASCII编码只能表示128个字符。遇到中文肯定无法处理，故国内使用GBK编码（一张更大的表）。
GBK是可变长度的编码，为兼容ASCII编码，使用了单、双字节编码和双字节编码，
小于127的字符，同ASCII表，大于127的，两个字节表示一个汉字。
故处理英文字符串时，和使用ASCII表存储的二进制数据一样。  

但处理中文时，如存储”你好”，GBK编码会把这个字符串编码成：

    11000100 11100011 10111010 11000011
“你”和”好”这分别用两个字节保存。此时使用ASCII编码保存就会报错，因ASCII编码中无”你”和”好”对应值。      

我们用GBK码保存文件，如果包含中文，别人使用ASCII就无法解码。
GBK文件只存ASCII码字符，解码时也正确，一般在文档中注明编码，打开时用对应的解码就好，但若文档中无编码信息，计算机就会猜测这是什么编码。
即使是中文，还有繁体中文，简体中文类别。即使知道文档是中文，也不知道用哪个中文编码才能正确打开。

## Unicode编码
其实最简单方法是，用很多二进制位来存储世界上所有字符。  
Unicode便是如此，它把每个国家的字符都编进去。如你好，对应 U+4F60 U+597D。
不同于其他编码，Unicode只是一个标准，规定了表现形式，而编码和解码则有其他方式。  

Unicode中每个字符都定义了对应表现形式：

    4f60 597d
    你   好
Unicode只指定表示形式，存储形式可据需选择。
如果每个字符都保存为4字节二进制（你好==00004f60，0000597d），这就是UTF-32编码。
已经可以用4个字节表达所有字符，没有其他技术问题。

## UTF-8编码
但传输”A”这个字符串，用UTF-32要用4个字节。而ASCII只要一个字节，这样会浪费存储空间和减缓传输速度。
UTF-8为减少存储，将常用字符（英文）用一个字节表示（ASCII），其他用两到四个字节表示。

UTF-8 UTF-32 对比

| character | encoding | bits                                | character |
| --------- | -------- | ----------------------------------- | --------- |
| A         | ASCII    | 01000001                            | A         |
| A         | Unicode  | 10011110 01000001(U+0041)           | A         |
| A         | UTF-32   | 00000000 00000000 00000000 01000001 | A         |
| A         | UTF-8    | 01000001                            | A         |
| 你       | ASCII    | 无法表示                        | 你       |
| 你       | Unicode  | 1001111 01100000(U+4f60)            | 你       |
| 你       | UTF-32   | 00000000 00000000 10011110 01100000 | 你       |
| 你       | UTF-8    | 11100100 10111101 10100000(e4bda0)  | 你       |
| character | encoding | bits                                | character |
| A         | ASCII    | 01000001                            | A         |
| A         | Unicode  | 10011110 01000001(U+0041)           | A         |
| 58        | :        | 75                                  | K         |
| 59        | ;        | 76                                  | L         |
| 60        | <        | 77                                  | M         |
| 61        | =        | 78                                  | N         |
| 62        | >        | 79                                  | O         |
| 63        | ?        | （省略）…                     | …       |
使用UTF-8编码后，”A”只要一个字节，汉字”你”从4个字节减少为3个。
Unicode转换成UTF-8非只要一张转换表：

Unicode范围	转换规则

| Unicode范围           | 转换规则                        |
| ----------------------- | ----------------------------------- |
| 0x00000000 - 0x0000007F | 0xxxxxxx                            |
| 0x00000080 - 0x000007FF | 110xxxxx 10xxxxxx                   |
| 0x00000800 - 0x0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx          |
| 0x00010000 - 0x001FFFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

以”你”为例，Unicode编码是U+4f60，对应第三列（07FF<4f60<FFFF），对比右边转换规则。
把4f60的二进制1001111 01100000从右到左填入转换规则的x中，空的填0。

    1001111 01100000 -> 1110xxxx 10xxxxxx 10xxxxxx -> 11100100 10111101 10100000
最后得到的11100100 10111101 10100000(e4bda0)也就是”你”的UTF-8编码了。


## HTML实体编码
浏览器解析HTML的时候会把特殊的字符串理解成非字面的含义，所以当需要显示这些特殊字符串的时候，需要经过下表的转换：

| 显示结果 | 描述   | 实体名称 | 实体编号      |
| -------- | -------- | -------- | ----------------- |
| 空格   | &nbsp;   | &#160;   | 空格            |
| <        | 小于号 | &lt;     | &#60;             |
| >        | 大于号 | &gt;     | &#62;             |
| &        | 和      | &amp;    | &#38;             |
| “      | 双引号 | &quot;   | &#34;             |
| ‘      | 单引号 | &apos;   | &#39;             |
| ′      | 重音符 | &acute;  | &#96;             |
| ©       | 版权   | &copy;   | &#169;            |
| ®       | 注册商标 | &reg;    | &#174;            |
| ™      | 商标   | &trade;  | &#8482;           |
| 你      | 中文   | &#x4F60; | &#x4F60;或&#20320 |
| 好      | 中文   | &#x597D; | &#x597D;或&#22909 |
从上表可以看到，特殊字符串是强制需要转换的，而且实际上，所有字符都可以经过转换表示，只需要用

    &#x加上其16进制Unicode编码或者
    &#加上其10进制Unicode编码
作为实体编号即可，浏览器既能解析字符串本身，也能解析其UTF-8编码。

## URL编码
RFC3986中规定了URI中不能出现

    : / ? # [ ] @ ! $ & ' ( ) * + , ; = 
当表示这些时，使用%加该字符的16进制UTF-8编码表示，出现非ASCII表的字符也一样，例如在浏览器输入

    https://www.example.com/你好

浏览器会自动把不合规定的字符转换成%加UTF-8编码再进行请求（地址栏还是显示原本”你好”），当你粘贴在文本编辑器的时候就可以看到原本的URL变成：

    https://www.example.com/%E4%BD%A0%E5%A5%BD

这里可以看到”你好”使用了它的UTF-8编码表示


## 总结
单纯从二进制数据是无法判断用什么编码存储的。但很早的AI成果就已很出色。